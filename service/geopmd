#!/usr/bin/env python3

#  Copyright (c) 2015 - 2021, Intel Corporation
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#      * Redistributions of source code must retain the above copyright
#        notice, this list of conditions and the following disclaimer.
#
#      * Redistributions in binary form must reproduce the above copyright
#        notice, this list of conditions and the following disclaimer in
#        the documentation and/or other materials provided with the
#        distribution.
#
#      * Neither the name of Intel Corporation nor the names of its
#        contributors may be used to endorse or promote products derived
#        from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

from dasbus.loop import EventLoop
from dasbus.connection import SystemMessageBus
import geopmdpy.pio

class GEOPMService(object):
    __dbus_xml__ = """
    <node>
        <interface name="io.github.geopm">
            <method name="AccessList">
                <arg direction="in" name="group" type="s" />
                <arg direction="out" name="allowed_signals" type="as" />
                <arg direction="out" name="allowed_controls" type="as" />
            </method>
            <method name="AccessControl">
                <arg direction="in" name="group" type="s" />
                <arg direction="in" name="allowed_signals" type="as" />
                <arg direction="in" name="denied_signals" type="as" />
                <arg direction="in" name="allowed_controls" type="as" />
                <arg direction="in" name="denied_controls" type="as" />
            </method>
            <method name="AccessDelete">
                <arg direction="in" name="group" type="s" />
            </method>
            <method name="AccessAllowed">
                <arg direction="out" name="allowed_signals" type="a(si)" />
                <arg direction="out" name="allowed_controls" type="a(si)" />
            </method>
            <method name="Loop">
                <arg direction="in" name="signals" type="a(sii)" />
                <arg direction="in" name="controls" type="a(sii)" />
                <arg direction="in" name="interval" type="d" />
                <arg direction="out" name="loop_pid" type="i" />
                <arg direction="out" name="signal_shmem" type="s" />
                <arg direction="out" name="control_shmem" type="s" />
                <arg direction="out" name="clock_start" type="(xx)" />
            </method>
            <method name="SignalInfo">
                <arg direction="in" name="query" type="as" />
                <arg direction="out" name="result" type="a(siii)" />
            </method>
            <method name="ControlInfo">
                 <arg direction="in" name="query" type="as" />
                 <arg direction="out" name="result" type="as" />
            </method>
            <method name="Test">
                <arg direction="out" name="result" type="(asas)" />
            </method>
        </interface>
    </node>
    """
    def __init__(self, pio=geopmdpy.pio):
        self._pio = pio

    def Test(self):
        return self._pio.signal_names(), self._pio.control_names()

    def AccessList(self, group):
        return self._pio.signal_names(), self._pio.control_names()

    def AccessControl(self, group,
                      allowed_signals, denied_signals,
                      allowed_controls, denied_controls):
        raise NotImplementedError

    def AccessDelete(self, group):
        raise NotImplementedError

    def AccessAllowed(self):
        signals = [(nn, self._pio.signal_domain_type(nn))
                   for nn in self._pio.signal_names()]
        controls = [(nn, self._pio.control_domain_type(nn))
                    for nn in self._pio.control_names()]
        return signals, controls

    def Loop(self, signals, controls, interval):
        # TODO: We need to write a PlatformIO method that will execute
        # the sampling/control loop in a pthread and call it through
        # the geopmdpy.pio CFFI interface.
        return 0, '/dev/shm/geopm-signal-0', '/dev/shm/geopm-control-0', (0, 0)

    def SignalInfo(self, query):
        result = []
        for signal_name in query:
            desc = self._pio.control_description(signal_name)
            # TODO: need to create python wrappers to get aggregation
            # function as an enum, format function as an enum and the
            # behavior enum, for now just returning all zeros
            result.append((desc, 0, 0, 0))
        return result

    def ControlInfo(self, query):
        result = []
        for control_name in query:
            result.append(self._pio.control_description(control_name))
        return result


def main():
    loop = EventLoop()
    bus = SystemMessageBus()
    bus.publish_object("/io/github/geopm", GEOPMService())
    bus.register_service("io.github.geopm")
    loop.run()

if __name__ == '__main__':
    main()
