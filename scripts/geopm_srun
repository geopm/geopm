#!/usr/bin/env python
#
#  Copyright (c) 2015, 2016, 2017, Intel Corporation
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#      * Redistributions of source code must retain the above copyright
#        notice, this list of conditions and the following disclaimer.
#
#      * Redistributions in binary form must reproduce the above copyright
#        notice, this list of conditions and the following disclaimer in
#        the documentation and/or other materials provided with the
#        distribution.
#
#      * Neither the name of Intel Corporation nor the names of its
#        contributors may be used to endorse or promote products derived
#        from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""
    geopm_srun <srun-options> [--geopm-ctl=<mode>]
        mode: One of the following strings
              "process" - Launch geopm controller as an mpi process.
              "pthread" - Launch geopm controller as a posix thread.
              "application" - Launch geopm controller as a separate MPI application (geopmctl).
"""
import sys
import os
import optparse
import subprocess

def geopm_srun_affinity(mode, num_rank, num_thread):
    """
    geopm_srun_affinty(mode, num_rank, num_thread)
        mode: One of the following strings
              "process" - geopm controller as an mpi process.
              "pthread" - geopm controller as a posix thread.
              "geopmctl" - for geopmctl application.
              "application" - for main application when launching with geopmctl.
        num_rank: Number of ranks per node used by main application.
        num_thread: Number of threads per rank used by main application.
    """
    result_base = '--cpu_bind=v,mask_cpu:'
    if mode == 'geopmctl':
        result = result_base + '0x1'
    else:
        mask_list = []
        if mode == 'process':
            mask_list.append('0x1')
            binary_mask = num_thread * '1' + '0'
        elif mode == 'pthread':
            binary_mask = (num_thread + 1) * '1'
        elif mode == 'application':
            binary_mask = num_thread * '1' + '0'
        else:
            raise NameError('Unknown mode: "{mode}", valid options are "process", "pthread", "geopmctl", or "application"'.format(mode=mode))
        for ii in range(num_rank):
            hex_mask = '0x{:x}'.format(int(binary_mask, 2))
            mask_list.append(hex_mask)
            if ii == 0 and mode == 'pthread':
                binary_mask = num_thread * '1' + '0'
            binary_mask = binary_mask + num_thread * '0'

        result = result_base + ','.join(mask_list)
    return result

class SubsetOptionParser(optparse.OptionParser):
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                optparse.OptionParser._process_args(self, largs, rargs, values)
            except (optparse.BadOptionError, optparse.AmbiguousOptionError) as e:
                largs.append(e.opt_str)

def swap_args(in_args):
    # Parse the subset of arguements used by geopm
    parser = SubsetOptionParser()
    parser.add_option('-n', '--ntasks', dest='num_rank', nargs=1, type='int')
    parser.add_option('-N', '--nodes', dest='num_node', nargs=1, type='int')
    parser.add_option('-c', '--cpus-per-task', dest='cpu_per_rank', nargs=1, type='int')
    parser.add_option('--geopm-ctl', dest='ctl', nargs=1, type='string')
    opts, args = parser.parse_args(in_args)

    if opts.ctl is None:
        args = in_args
        ctl = None
    else:
        # Check required arguements and add a rank per node for the controller
        if opts.num_rank is None:
            raise SyntaxError('Number of tasks must be specified with -n.')
        if opts.num_node is None:
            raise SyntaxError('Number of nodes must be specified with -N.')
        if '--cpu_bind' in args:
            raise SyntaxError('The option --cpu_bind must not be specified, this is controlled by geopm_srun.')
        ctl = opts.ctl
        num_rank = opts.num_rank
        num_node = opts.num_node
        if ctl not in ('process', 'pthread', 'application'):
            raise SyntaxError('--geopm-ctl must be one of: "process", "pthread", or "application"')
        if opts.cpu_per_rank is None:
            cpu_per_rank = int(os.environ.get('OMP_NUM_THREADS', '1'))
        else:
            cpu_per_rank = opts.cpu_per_rank
        if ctl == 'process':
            num_rank += num_node

        # Put back modified -n and -N
        geopm_args = ['-n', str(num_rank), '-N', str(num_node)]
        # Add affinity mask for geopm
        geopm_args.extend(geopm_srun_affinity(ctl, num_rank / num_node, cpu_per_rank).split())
        geopm_args.extend(args)
        args = geopm_args
    # Put srun at head of the arguments
    args.insert(0, 'srun')
    return ctl, args

def main():
    help_msg = """\
GEOPM options:
      --geopm-ctl=ctl         use geopm runtime and launch geopm with the
                              "ctl" method, one of "process", "pthread" or
                              "application"

"""
    err = 0
    args = sys.argv[1:]
    # Print srun help if requested
    if '--help' in args or '-h' in args:
        args.insert(0, 'srun')
        pid = subprocess.Popen(args)
        pid.wait()
        sys.stdout.write(help_msg)
        err = pid.returncode
    else:
        ctl, args = swap_args(args)
        if ctl is None:
            pid = subprocess.Popen(args)
            pid.wait()
            err = pid.returncode
        if ctl in ('process', 'pthread'):
            env = os.environ;
            env['GEOPM_PMPI_CTL'] = ctl
            sys.stdout.write('GEOPM_PMPI_CTL={ctl} '.format(ctl=ctl) + ' '.join(args) + '\n')
            pid = subprocess.Popen(args, env=env)
            pid.wait()
            err = pid.returncode
        elif ctl == 'application':
            raise NotImplementedError('Launching geopm as separate MPI application not yet supported by geopm_srun.')
    sys.exit(err)

if __name__ == '__main__':
    try:
        err = main()
    except Exception as e:
        sys.stderr.write("<geopm_srun> {err}\n".format(err=e))
        err = -1
    sys.exit(err)
