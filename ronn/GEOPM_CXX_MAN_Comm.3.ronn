geopm::Comm(3) -- communication abstractions
============================================

[//]: # (Copyright (c) 2015, 2016, 2017, 2018, Intel Corporation)
[//]: # ()
[//]: # (Redistribution and use in source and binary forms, with or without)
[//]: # (modification, are permitted provided that the following conditions)
[//]: # (are met:)
[//]: # ()
[//]: # (    * Redistributions of source code must retain the above copyright)
[//]: # (      notice, this list of conditions and the following disclaimer.)
[//]: # ()
[//]: # (    * Redistributions in binary form must reproduce the above copyright)
[//]: # (      notice, this list of conditions and the following disclaimer in)
[//]: # (      the documentation and/or other materials provided with the)
[//]: # (      distribution.)
[//]: # ()
[//]: # (    * Neither the name of Intel Corporation nor the names of its)
[//]: # (      contributors may be used to endorse or promote products derived)
[//]: # (      from this software without specific prior written permission.)
[//]: # ()
[//]: # (THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS)
[//]: # ("AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT)
[//]: # (LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR)
[//]: # (A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT)
[//]: # (OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,)
[//]: # (SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT)
[//]: # (LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,)
[//]: # (DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY)
[//]: # (THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT)
[//]: # ((INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY LOG OF THE USE)
[//]: # (OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.)

## SYNOPSIS

**\#include [<geopm/Comm.hpp>](https://github.com/geopm/geopm/blob/dev/src/Comm.hpp)**

`Link with -lgeopm (MPI) or -lgeopmpolicy (non-MPI)`

  * `std::shared_ptr<Comm> split(`:
    `void);`

  * `std::shared_ptr<Comm> split(`:
    `int `_color_`,`<br>
    `int `_key_`);`

  * `std::shared_ptr<Comm> split(`:
    `const std::string &`_tag_`,`<br>
    `int `_split_type_`);`

  * `std::shared_ptr<Comm> split(`:
    `std::vector<int> `_dimensions_`,`<br>
    `std::vector<int> `_periods_`,`<br>
    `bool `_is_reorder_`);`

  * `std::shared_ptr<Comm> split_cart(`:
    `std::vector<int> `_dimensions_`);`

  * `bool comm_supported(`:
    `const std::string &`_description_`);`

  * `int cart_rank(`:
    `const std::vector<int> &`_coords_`);`

  * `int rank(`:
    `void);`

  * `int num_rank(`:
    `void);`

  * `void dimension_create(`:
    `int `_num_ranks_`,`<br>
    `std::vector<int> &`_dimension_`);`

  * `void free_mem(`:
    `void *`_base_`);`

  * `void alloc_mem(`:
    `size_t `_size_`,`<br>
    `void **`_base_`);`

  * `size_t window_create(`:
    `size_t `_size_`,`<br>
    `void *`_base_`);`

  * `void window_destroy(`:
    `size_t `_window_id_`);`

  * `void window_lock(`:
    `size_t `_window_id_`,`<br>
    `bool `_is_exclusive_`,`<br>
    `int `_rank_`,`<br>
    `int `_assert_`);`

  * `void window_unlock(`:
    `size_t `_window_id_`,`<br>
    `int `_rank_`);`

  * `void coordinate(`:
    `int `_rank_`,`<br>
    `std::vector<int> &`_coord_`);`

  * `std::vector<int> coordinate(`:
    `int `_rank_`);`

  * `void barrier(`:
    `void);`

  * `void broadcast(`:
    `void *`_buffer_`,`<br>
    `size_t `_size_`,`<br>
    `int `_root_`);`

  * `bool test(`:
    `bool `_is_true_`);`

  * `void reduce_max(`:
    `double *`_send_buf_`,`<br>
    `double *`_recv_buf_`,`<br>
    `size_t `_count_`,`<br>
    `int `_root_`);`

  * `void gather(`:
    `const void *`_send_buf_`,`<br>
    `size_t `_send_size_`,`<br>
    `void *`_recv_buf_`,`<br>
    `size_t `_recv_size_`,`<br>
    `int `_root_`);`

  * `void gatherv(`:
    `const void *`_send_buf_`,`<br>
    `size_t `_send_size_`,`<br>
    `void *`_recv_buf_`,`<br>
    `const std::vector<size_t> &`_recv_sizes_`,`<br>
    `const std::vector<off_t> &`_rank_offset_`,`<br>
    `int `_root_`);`

  * `void window_put(`:
    `const void *`_send_buf_`,`<br>
    `size_t `_send_size_`,`<br>
    `int `_rank_`,`<br>
    `off_t `_disp_`,`<br>
    `size_t `_window_id_`);`

  * `void tear_down(`:
    `void);`

  * `PluginFactory<Comm>& comm_factory(`:
    `void);`

# DESCRIPTION
The Comm interface is an abstraction for interprocess communication.
Although there is only one implementation, MPIComm, this interface
allows limiting dependences on MPI to a small number of files.

## CLASS METHODS

  * `split`():


  * `split`():


  * `split`():


  * `split`():


  * `split_cart`():

  * `comm_supported`():

## INTROSPECTION METHODS

  * `cart_rank`():
    Process rank within Cartesian communicator
    [in] coords Coordinate of Cartesian communicator member
    whose rank we wish to know.

  * `rank`():
    Process rank within communicator

  * `num_rank`():
    Number of ranks in the communicator

  * `dimension_create`():
    Populate vector of optimal dimensions given the number of ranks the communicator
    [in] num_ranks Number of ranks that must fit in Cartesian grid.
    [in, out] dimension Number of ranks per dimension.  The size of this vector
    dictates the number of dimensions in the grid.  Fill indecies with 0 for API
    to fill with suitable value.

  * `free_mem`():
    Free memory that was allocated for message passing and RMA
    [in] base Address of memory to be released.

  * `alloc_mem`():
    Allocate memory for message passing and RMA
    [in] size Size of the desired memory allocation.
    [out] base Address of allocated memory.

  * `window_create`():
    Create window for message passing and RMA
    returns window handle for subsequent operations
    on the window.
    [in] size Size of the memory area backing the RMA window.
    [in] base Address of memory that has been allocated
    for the window.

  * `window_destroy`():
    Destroy window for message passing and RMA
    [in] window_id The window handle for the target window.

  * `window_lock`():
    Begin epoch for message passing and RMA.
    [in] window_id The window handle for the target window.
    [in] is_exclusive Lock type for the window,
    true for exclusive lock, false for shared.
    [in] rank Rank of the locked window.
    [in] assert Used to optimize call.

  * `window_unlock`():
    End epoch for message passing and RMA
    [in] window_id The window handle for the target window.
    [in] rank Rank of the locked window.

  * `coordinate`():
    Coordinate in Cartesian grid for specified rank
    [in] rank Rank for which coordinates should be calculated
    [in, out] coord Cartesian coordinates of specified rank.
    The size of this vector should equal the number of dimensions
    that the Cartesian communicator was created with.

  * `coordinate`():

## COLLECTIVE COMMUNICATION METHODS

  * `barrier`():
    Barrier for all ranks

  * `broadcast`():
    Broadcast a message to all ranks
    [in, out] buffer Starting address of buffer to be broadcasted.
    [in] size Size of the buffer.
    [in] root Rank of the broadcast root (target).

  * `test`():
    Test whether or not all ranks in the communicator present
    the same input and return true/false accordingly.
    [in] is_true Boolean value to be reduced from all ranks.

  * `reduce_max`():
    Reduce distributed messages across all ranks using specified operation, store result on all ranks
    [in] send_buf Start address of memory buffer to be trasnmitted.
    [out] recv_buf Start address of memory buffer to receive data.
    [in] count Size of buffer in bytes to be transmitted.

  * `gather`():
    Gather bytes from all processes
    [in] send_buf Start address of memory buffer to be trasnmitted.
    [in] send_size Size of buffer to be sent.
    [out] recv_buf Start address of memory buffer to receive data.
    [in] recv_size The size of the buffer to be received.
    [in] root Rank of the target for the transmission.

  * `gatherv`():
    Gather bytes into specified location from all processes
    [in] send_buf Start address of memory buffer to be trasnmitted.
    [in] send_size Size of buffer to be sent.
    [out] recv_buf Start address of memory buffer to receive data.
    [in] recv_sizes Vector describing the buffer size per rank to be received.
    [in] rank_offset Offset per rank into target buffer for transmitted data.
    [in] root Rank of the target for the transmission.

  * `window_put`():
    Perform message passing or RMA.
    [in] send_buf Starting address of buffer to be transmitted via window.
    [in] send_size Size if bytes of buffer to be sent.
    [in] rank Target rank of the transmission.
    [in] disp Displacement from start of window.
    [in] window_id The window handle for the target window.

  * `tear_down`():
    Clean up resources held by the comm.  This
    allows static global objects to be cleaned up
    before the destructor is called.


## ENUMERATIONS
enum m_comm_split_type_e {
M_COMM_SPLIT_TYPE_PPN1,
M_COMM_SPLIT_TYPE_SHARED,
M_NUM_COMM_SPLIT_TYPE
};
enum m_split_color_e {
M_SPLIT_COLOR_UNDEFINED = -16,
};

## FACTORY ACCESSOR

  * `comm_factory`():
    This method returns the singleton accessor for the Comm factory.
    Calling this method will create the factory if it does not already exist.
    For more information see **geopm::PluginFactory(3)**.

## COPYRIGHT
Copyright (c) 2015, 2016, 2017, 2018, Intel Corporation. All rights reserved.

## SEE ALSO
**geopm(7)**
